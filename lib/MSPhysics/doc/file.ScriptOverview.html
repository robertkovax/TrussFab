<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: ScriptOverview
  
    &mdash; Documentation by YARD 0.9.9
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/custom.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "ScriptOverview";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: ScriptOverview</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'>
<h1 id="label-Script+Overview">Script Overview</h1>

<p>This overview focus more on scripting rather than the general use. You may
click on the <a
href="https://github.com/AntonSynytsia/MSPhysics/wiki">Wiki</a> link for
information about the general use.</p>

<h2 id="label-Scripting+Documentation">Scripting Documentation</h2>

<p>Scripting in MSPhysics is very similar to SketchyPhysics. The process is
very simple; you select a desired group, open MSPhysics UI, and activate
the scripting tab. Every group, being part of simulation, has its own body
context, an instance of <span class='object_link'><a href="MSPhysics/Body.html" title="MSPhysics::Body (class)">MSPhysics::Body</a></span> class.
<code>MSPhysis::Body</code> class contains a set of useful functions and
events, allowing user to have control over body in physics world. Refer to
a simple tutorial below to get more familiar with scripting.</p>

<h2 id="label-Controllable+Sphere+Tutorial">Controllable Sphere Tutorial</h2>

<p>In this tutorial we will create a sphere and control it with keyboard.</p>
<ol><li>
<p>To get you started, open SketchUp and create a floor group, settings its 
shape to "Static Mesh" ([Context Menu] MSPhysics -&gt; Shape -&gt; Static
Mesh).</p>
</li><li>
<p>Now that you have a floor, create a sphere or even a cube over the floor, 
and set its shape to "Sphere".</p>
</li><li>
<p>Now select the sphere group, open MSPhysics UI, activate the scripting tab,
and paste this code in it:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Triggered when simulation starts
</span><span class='id identifier rubyid_onStart'>onStart</span> <span class='lbrace'>{</span>
  <span class='comment'># Have the desired velocity as 5 m/s
</span>  <span class='ivar'>@des_vel</span> <span class='op'>=</span> <span class='int'>5</span>
<span class='rbrace'>}</span>

<span class='comment'># Triggered every time the world updates
</span><span class='id identifier rubyid_onUpdate'>onUpdate</span> <span class='lbrace'>{</span>
  <span class='comment'># Compute the force to apply
</span>  <span class='id identifier rubyid_timestep'>timestep</span> <span class='op'>=</span> <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_update_timestep'>update_timestep</span> <span class='comment'># (in seconds)
</span>  <span class='id identifier rubyid_force'>force</span> <span class='op'>=</span> <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_mass'>mass</span> <span class='op'>/</span> <span class='id identifier rubyid_timestep'>timestep</span> <span class='comment'># (in Newtons)
</span>  <span class='comment'># Get current velocity
</span>  <span class='id identifier rubyid_cur_vel'>cur_vel</span> <span class='op'>=</span> <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_get_velocity'>get_velocity</span>
  <span class='comment'># leftx() returns a value ranging from -1.0 to 1.0, depending on the state
</span>  <span class='comment'># of A and D keys or the horizontal position of the left joystick.
</span>  <span class='id identifier rubyid_fx'>fx</span> <span class='op'>=</span> <span class='lparen'>(</span><span class='id identifier rubyid_leftx'>leftx</span><span class='lparen'>(</span><span class='rparen'>)</span> <span class='op'>*</span> <span class='ivar'>@des_vel</span> <span class='op'>-</span> <span class='id identifier rubyid_cur_vel'>cur_vel</span><span class='period'>.</span><span class='id identifier rubyid_x'>x</span><span class='rparen'>)</span> <span class='op'>*</span> <span class='id identifier rubyid_force'>force</span>
  <span class='comment'># lefty() returns a value ranging from -1.0 to 1.0, depending on the state
</span>  <span class='comment'># of W and S keys or the vertical position of the left joystick.
</span>  <span class='id identifier rubyid_fy'>fy</span> <span class='op'>=</span> <span class='lparen'>(</span><span class='id identifier rubyid_lefty'>lefty</span><span class='lparen'>(</span><span class='rparen'>)</span> <span class='op'>*</span> <span class='ivar'>@des_vel</span> <span class='op'>-</span> <span class='id identifier rubyid_cur_vel'>cur_vel</span><span class='period'>.</span><span class='id identifier rubyid_y'>y</span><span class='rparen'>)</span> <span class='op'>*</span> <span class='id identifier rubyid_force'>force</span>
  <span class='comment'># Apply force on this body.
</span>  <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_add_force'>add_force</span><span class='lparen'>(</span><span class='id identifier rubyid_fx'>fx</span><span class='comma'>,</span> <span class='id identifier rubyid_fy'>fy</span><span class='comma'>,</span> <span class='int'>0</span><span class='rparen'>)</span>
<span class='rbrace'>}</span>
</code></pre>
</li><li>
<p>Start simulation and control the sphere with W,S,A,D keys or left joystick.</p>
</li><li>
<p>All you&#39;re left to do is create a simple maze in the staticmesh group,
and  there you have your first simple game.</p>
</li></ol>

<h2 id="label-Scripting+Reference">Scripting Reference</h2>
<ul><li>
<p>See <span class='object_link'><a href="MSPhysics/Simulation.html" title="MSPhysics::Simulation (class)">MSPhysics::Simulation</a></span> for various functions in simulation. Access
from  the body context:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onUpdate'>onUpdate</span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_some_simulation_method'>some_simulation_method</span>
  <span class='comment'># Or (Accessible from everywhere)
</span>  <span class='const'><span class='object_link'><a href="MSPhysics.html" title="MSPhysics (module)">MSPhysics</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="MSPhysics/Simulation.html" title="MSPhysics::Simulation (class)">Simulation</a></span></span><span class='period'>.</span><span class='id identifier rubyid_instance'><span class='object_link'><a href="MSPhysics/Simulation.html#instance-class_method" title="MSPhysics::Simulation.instance (method)">instance</a></span></span><span class='period'>.</span><span class='id identifier rubyid_some_simulation_method'>some_simulation_method</span>
<span class='rbrace'>}</span>
</code></pre>
</li><li>
<p>See <span class='object_link'><a href="MSPhysics/World.html" title="MSPhysics::World (class)">MSPhysics::World</a></span> for various function in the current world. Access
from  the body context:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onUpdate'>onUpdate</span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_world'>world</span><span class='period'>.</span><span class='id identifier rubyid_some_world_method'>some_world_method</span>
  <span class='comment'># OR
</span>  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_world'>world</span><span class='period'>.</span><span class='id identifier rubyid_some_world_method'>some_world_method</span>
  <span class='comment'># OR (Accessible from everywhere)
</span>  <span class='const'><span class='object_link'><a href="MSPhysics.html" title="MSPhysics (module)">MSPhysics</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="MSPhysics/Simulation.html" title="MSPhysics::Simulation (class)">Simulation</a></span></span><span class='period'>.</span><span class='id identifier rubyid_instance'><span class='object_link'><a href="MSPhysics/Simulation.html#instance-class_method" title="MSPhysics::Simulation.instance (method)">instance</a></span></span><span class='period'>.</span><span class='id identifier rubyid_world'><span class='object_link'><a href="MSPhysics/Simulation.html#world-instance_method" title="MSPhysics::Simulation#world (method)">world</a></span></span><span class='period'>.</span><span class='id identifier rubyid_some_world_method'>some_world_method</span>
<span class='rbrace'>}</span>
</code></pre>
</li><li>
<p>See <span class='object_link'><a href="MSPhysics/CommonContext.html" title="MSPhysics::CommonContext (class)">MSPhysics::CommonContext</a></span> for various common functions accessible in
the  body context and controller context.  Access from the controller
context: <code>some_common_method</code>.  Access from the body context:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onUpdate'>onUpdate</span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_some_common_method'>some_common_method</span>
<span class='rbrace'>}</span>
</code></pre>
</li><li>
<p>See <span class='object_link'><a href="MSPhysics/BodyContext.html" title="MSPhysics::BodyContext (class)">MSPhysics::BodyContext</a></span> for various events accessible in the body 
context. The <code>MSPhysics::BodyContext</code> encapsulates 
<code>MSPhysics::Body</code> instance. See <span class='object_link'><a href="MSPhysics/Body.html" title="MSPhysics::Body (class)">MSPhysics::Body</a></span> for various
functions  accessible from every body in simulation. Note that in order to
call a body  method, you must have a <code>this</code> key word in front,
for example,  <code>this.mass = 20</code>.  Access from the body context:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onUpdate'>onUpdate</span> <span class='lbrace'>{</span> <span class='comment'># An event belonging to MSPhysics::BodyContext
</span>  <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_some_body_method'>some_body_method</span> <span class='comment'># A method belonging to MSPhysics::Body
</span><span class='rbrace'>}</span>
</code></pre>
</li><li>
<p>See <span class='object_link'><a href="MSPhysics/ControllerContext.html" title="MSPhysics::ControllerContext (class)">MSPhysics::ControllerContext</a></span> for various functions accessible in the 
controllers. Access from the controller context: 
<code>some_controller_method</code></p>
</li></ul>

<h2 id="label-Accessing+Simulation+Instance">Accessing Simulation Instance</h2>

<p>As described above, use the following code snippets to get reference to the
<span class='object_link'><a href="MSPhysics/Simulation.html" title="MSPhysics::Simulation (class)">MSPhysics::Simulation</a></span> instance:</p>
<ul><li>
<p><code>simulation</code> - accessible within BodyContext and
ControllerContext scopes only.</p>
</li><li>
<p><code>MSPhysics::Simulation.instance</code> - accessible from all scopes.</p>
</li></ul>

<p>Displaying frame using <code>log_line</code> or <code>display_note</code>
functions:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onUpdate'>onUpdate</span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_log_line'>log_line</span><span class='lparen'>(</span><span class='id identifier rubyid_frame'>frame</span><span class='rparen'>)</span>
  <span class='comment'># OR
</span>  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_display_note'>display_note</span><span class='lparen'>(</span><span class='id identifier rubyid_frame'>frame</span><span class='rparen'>)</span>
<span class='rbrace'>}</span>
</code></pre>

<h2 id="label-Script+Errors">Script Errors</h2>

<p>All detected script errors will cause simulation to reset. A message box
will pop up displaying an error. Along with that, MSPhysics UI will attempt
to locate script and the line number associated with an error. Script
errors in the controller contexts are outputted in Ruby Console rather than
resetting simulation.</p>

<h2 id="label-Deleted+Bodies-2FEntities">Deleted Bodies/Entities</h2>

<p>Deleted entities/bodies in simulation are handled safely. Deleting an
entity that belongs to some Body instance will keep simulation running,
however, referenced body will remain alive until simulation is complete. To
destroy the referenced body, call <code>Body.#destroy</code>. You may also
call <code>Body.#destroy(true)</code> to destroy body along with referenced
entity at once.</p>

<p>Calling any methods of a destroyed body, except for the
<code>Body.#valid?</code> method, will result in a TypeError causing
simulation to reset. It is a good practice to check if body is valid prior
to using its functions.</p>

<h2 id="label-Resetting+Simulation+via+Script">Resetting Simulation via Script</h2>

<p>Use <code>MSPhysics::Simulation.reset</code> in any scope.</p>

<h2 id="label-Variables">Variables</h2>
<ul><li>
<p>Use instance variables (<code>@my_var</code>) to implement data within the
current  body&#39;s scope.</p>
</li><li>
<p>Use class variables (<code>@@my_var</code>) or
<code>get_var</code>/<code>set_var</code>/<code>get_set_var</code> 
functions to implement data under all body scopes and controllers.</p>
</li><li>
<p>Minimize the use of global variables (<code>$my_var</code>) as using plenty
of  them is considered a bad coding habit.</p>
</li></ul>

<h2 id="label-Shapes">Shapes</h2>
<ul><li>
<p><strong>Box</strong> - A rectangular prism collision shape that has its
width, height, and  depth determined by the bounding box of a group.</p>
</li><li>
<p><strong>Sphere</strong> - A spherical collision shape with width, height,
or depth  determined by the bounding box of a group.</p>
</li><li>
<p><strong>Cone</strong> - A conical collision shape with diameter and height
determined by a  bounding box of a group.</p>
</li><li>
<p><strong>Cylinder</strong> - A cylindrical collision shape with diameter and
height  determined by the bounding box of a group.</p>
</li><li>
<p><strong>Chamfer Cylinder</strong> - A cylindrical collision shape with
rounded corners.  Dimensions are determined by the bounding box of a group.</p>
</li><li>
<p><strong>Capsule</strong> - A stretched/compressed spherical collision
shape. Dimensions are  determined by the bounding box of a group.</p>
</li><li>
<p><strong>Convex Hull</strong> - A convex collision shape calculated from all
the faces in a  group/component.</p>
</li><li>
<p><strong>Compound</strong> - A compound collision with all sub-geometry and
sub-groups  considered as separate convex hulls.</p>
</li><li>
<p><strong>Compound from CD</strong> - A compound collision with convex hulls
calculated by a  convex decomposition algorithm.</p>
</li><li>
<p><strong>Static Mesh</strong> - A static tree collision derived from all
faces of a group.</p>
</li><li>
<p><strong>Null</strong> - A dynamic collision shape with no collision. Useful
for linker  bodies, such as the neck of a rag-doll.</p>
</li></ul>

<h2 id="label-Shape+Notes">Shape Notes</h2>
<ul><li>
<p>Entity&#39;s transformation X-axis is used as a default up indicator for
collision  shapes like cone and cylinder.</p>
</li><li>
<p>A bounding box, which is used to determine dimensions for many collision 
shapes, is not the actual group&#39;s/component&#39;s bounding box, but
rather a  custom one, calculated from all the faces within a
group/component. This means  that all edges, points, and construction
geometry inside a group or a  component are not taken into consideration in
calculating the size of a  collision bounding box.</p>
</li><li>
<p>Make sure to have all back faces inside and all front faces outside as
Newton  calculates collision intersections based on front faces only. This
applies to  static mesh and compound from mesh collision shapes.</p>
</li><li>
<p>A group/component will not be added to simulation if its calculated
bounding  box turns out flat or empty. This applies to all collision shapes
except  “Null” and “Static Mesh”, as “Null” collisions don&#39;t have any
collisions and  “Static Mesh” collisions may be flat.</p>
</li><li>
<p>A group/component will not be added to simulation if its faces are all 
coplanar. This applies to convex hull collision shape, which also applies
to  compound shapes since their collision consists of convex
sub-collisions.</p>
</li><li>
<p>A group/component will not be added to simulation if its axis are not 
perpendicular to each other. Non-uniform transformation are not tolerated
by  Newton.</p>
</li><li>
<p>The collisions for scaled and flipped groups/components are computed
properly.</p>
</li></ul>

<h2 id="label-Tips+-26+Security">Tips &amp; Security</h2>
<ul><li>
<p>Avoid calling start/abort/commit operation or undo/redo while simulation is
running; otherwise, simulation could behave improperly.</p>
</li><li>
<p>Minimize the use of the <strong>Compound From CD</strong> shape as it takes
time to  generate collision and collision isn&#39;t always generated
properly.</p>
</li><li>
<p>Increase world scale if dealing with tiny objects.</p>
</li><li>
<p>Avoid the use of high poly models as they could cause lag or result in a 
BugSplat while generating collision (very unlikely but may happen).</p>
</li><li>
<p>Apply clean-up to your model before uploading it to 3DWarehouse as cleanup 
could decrease file size and improve performance. <a
href="http://sketchucation.com/forums/viewtopic.php?f=323&t=22920">TT
CleanUp</a>  plugin is recommended!</p>
</li><li>
<p>Add <em>MSPhysics</em> to the tags list when uploading your model to 
3DWarehouse. This way people searching 3DWarehouse would easily find your 
model by writing “MSPhysics” in the search box. Searchers could sort search
results by uploaded date to find the most recent uploads.</p>
</li></ul>

<h2 id="label-Game+Mode">Game Mode</h2>

<p>When it comes to creating games, like FPS, there are two commands to
consider adding to Body Script tab:</p>
<ol><li>
<p>Enable game mode. <em>Game mode</em> disables pick-and-drag tool and gives 
scripter full control over user input. For instance, the mouse wheel could
be  used to switch weapons, rather than being a shortcut for a zoom tool.
This  can be done with the <code>MSPhysics::Simulation.#mode=}</code>
command:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onStart'>onStart</span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_mode'>mode</span> <span class='op'>=</span> <span class='int'>1</span>
  <span class='comment'># ...
</span><span class='rbrace'>}</span>
<span class='id identifier rubyid_onMouseWheelRotate'>onMouseWheelRotate</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span><span class='comma'>,</span> <span class='id identifier rubyid_dir'>dir</span><span class='op'>|</span>
  <span class='comment'># Do something...
</span><span class='rbrace'>}</span>
</code></pre>
</li><li>
<p>Set view full screen. This can be done with the 
<code>MSPhysics::Simulation.view_full_screen</code> command:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onStart'>onStart</span> <span class='lbrace'>{</span>
  <span class='comment'># Set viewport full screen when simulation starts.
</span>  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_view_full_screen'>view_full_screen</span><span class='lparen'>(</span><span class='kw'>true</span><span class='rparen'>)</span>
<span class='rbrace'>}</span>
<span class='id identifier rubyid_onEnd'>onEnd</span> <span class='lbrace'>{</span>
  <span class='comment'># Set viewport back to original placement when simulation resets.
</span>  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_view_full_screen'>view_full_screen</span><span class='lparen'>(</span><span class='kw'>false</span><span class='rparen'>)</span>
<span class='rbrace'>}</span>
</code></pre>
</li></ol>

<h2 id="label-Optimization+-26+Performance">Optimization &amp; Performance</h2>
<ul><li>
<p>The slower the speed (smaller update timestep), the more accurate the 
simulation is.</p>
</li><li>
<p>Use exact solver model when precision is more important than speed.</p>
</li><li>
<p>Use iterative solver model when speed is more important than precision.</p>
</li><li>
<p>To improve performance in general, go to <em>Preferences -&gt; OpenGL</em>
and  reduce <em>Anti-Aliasing</em> as poor performance could be caused by
slow  graphics processing.</p>
</li><li>
<p>Sometimes, performance lag could be caused by an anti-virus software, 
particularly Windows Defender on Windows 10. Disabling it should yield
better  performance.</p>
</li><li>
<p>Use iterative solver when simulating stacked geometry, like walls, as exact
solver might result in lag.</p>
</li><li>
<p>Enable continuous collision check or reduce simulation speed to prevent 
objects from passing or penetrating through each other at high speeds.</p>
</li></ul>

<h2 id="label-Music+-26+Sound">Music &amp; Sound</h2>

<p>MSPhysics uses SDL and SDL Mixer for its music and sound API. Use MSPhysics
UI sound tab to embed sounds. When adding sounds, be cautious of file size
as model size increases significantly. The difference between music and
sound is that only one music can be mixed and played at a time, meanwhile
up to 20 sounds can be played simultaneously. In games, music is used as
background music and sounds are used as effects. Another difference between
music and sound is that music can be played of various formats, meanwhile
sound is limited to a few formats. Use <code>simulation.play_music</code>
in body context to play music. Use <code>simulation.play_sound</code> in
body context to play sound.</p>

<p>To play sound in 3d, use <code>simulation.position_sound</code> command:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onKeyDown'>onKeyDown</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_k'>k</span><span class='comma'>,</span> <span class='id identifier rubyid_v'>v</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>|</span>
  <span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_play_sound'>play_sound</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ping</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># Play sound and get channel
</span>  <span class='id identifier rubyid_pos'>pos</span> <span class='op'>=</span> <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_group'>group</span><span class='period'>.</span><span class='id identifier rubyid_bounds'>bounds</span><span class='period'>.</span><span class='id identifier rubyid_center'>center</span> <span class='comment'># Sound position in global space
</span>  <span class='id identifier rubyid_range'>range</span> <span class='op'>=</span> <span class='int'>500</span> <span class='comment'># Hearing range in meters
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_channel'>channel</span> <span class='op'>!=</span> <span class='kw'>nil</span>
    <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_position_sound'>position_sound</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='int'>500</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='rbrace'>}</span>
</code></pre>

<h2 id="label-Joystick">Joystick</h2>

<p>Joystick is accessible from the common context which is inherited by the
body and controller context. See <span class='object_link'><a href="MSPhysics/CommonContext.html" title="MSPhysics::CommonContext (class)">MSPhysics::CommonContext</a></span> for various
functions and their examples about joystick. Here is a simple example which
outputs the state of the left joystick onto screen:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onTick'>onTick</span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_x'>x</span> <span class='op'>=</span> <span class='id identifier rubyid_joystick'>joystick</span><span class='lparen'>(</span><span class='symbol'>:leftx</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_y'>y</span> <span class='op'>=</span> <span class='id identifier rubyid_joystick'>joystick</span><span class='lparen'>(</span><span class='symbol'>:lefty</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_txt'>txt</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>xaxis </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_x'>x</span><span class='embexpr_end'>}</span><span class='tstring_content'>\nyaxis </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_y'>y</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_display_note'>display_note</span><span class='lparen'>(</span><span class='id identifier rubyid_txt'>txt</span><span class='rparen'>)</span>
<span class='rbrace'>}</span>
</code></pre>

<p>Note that xbox or any other joystick controller must be attached to PC
before SketchUp starts. Otherwise the joystick commands won&#39;t respond
to it.</p>

<h2 id="label-Joints">Joints</h2>

<p>Besides creating and connecting joints using the joint tool, it is possible
to create joints using the MSPhysics API. Assume you have to bodies in
world; one named &#39;body1&#39; and the other named &#39;body2&#39;. Here
is a way to connect these two bodies once they come in contact with each
other:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Paste this script into &#39;body1&#39;
</span><span class='id identifier rubyid_onStart'>onStart</span> <span class='lbrace'>{</span>
  <span class='ivar'>@joint</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="MSPhysics.html" title="MSPhysics (module)">MSPhysics</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="MSPhysics/Fixed.html" title="MSPhysics::Fixed (class)">Fixed</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="MSPhysics/Fixed.html#initialize-instance_method" title="MSPhysics::Fixed#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_world'>world</span><span class='comma'>,</span> <span class='id identifier rubyid_this'>this</span><span class='comma'>,</span> <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_get_matrix'>get_matrix</span><span class='comma'>,</span> <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_group'>group</span><span class='rparen'>)</span>
  <span class='comment'># Disconnect joint when the applied force is reaches or passes the desired
</span>  <span class='comment'># breaking force.
</span>  <span class='comment'>#@joint.breaking_force = 50000
</span><span class='rbrace'>}</span>

<span class='id identifier rubyid_onTouch'>onTouch</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_toucher'>toucher</span><span class='comma'>,</span> <span class='id identifier rubyid_point'>point</span><span class='comma'>,</span> <span class='id identifier rubyid_normal'>normal</span><span class='comma'>,</span> <span class='id identifier rubyid_force'>force</span><span class='comma'>,</span> <span class='id identifier rubyid_speed'>speed</span><span class='op'>|</span>
  <span class='comment'># Check if the touching body is &#39;body2&#39; and connect only if the joint is
</span>  <span class='comment'># not already connected.
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_toucher'>toucher</span><span class='period'>.</span><span class='id identifier rubyid_group'>group</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>body2</span><span class='tstring_end'>&#39;</span></span> <span class='op'>&amp;&amp;</span> <span class='ivar'>@joint</span><span class='period'>.</span><span class='id identifier rubyid_valid?'>valid?</span> <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='ivar'>@joint</span><span class='period'>.</span><span class='id identifier rubyid_connected?'>connected?</span>
    <span class='ivar'>@joint</span><span class='period'>.</span><span class='id identifier rubyid_connect'>connect</span><span class='lparen'>(</span><span class='id identifier rubyid_toucher'>toucher</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
  <span class='comment'># Once the joint is connected it can be disconnected with @joint.disconnect command.
</span><span class='rbrace'>}</span>
</code></pre>

<p>MSPhysics has many joints and all of them can be created and controlled
with the MSPhysics API. Refer to the list below for documentation links to
all the joints:</p>
<ul><li>
<p><span class='object_link'><a href="MSPhysics/Joint.html" title="MSPhysics::Joint (class)">MSPhysics::Joint</a></span> an abstract of common functions for all joints.</p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Hinge.html" title="MSPhysics::Hinge (class)">MSPhysics::Hinge</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Motor.html" title="MSPhysics::Motor (class)">MSPhysics::Motor</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Servo.html" title="MSPhysics::Servo (class)">MSPhysics::Servo</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Slider.html" title="MSPhysics::Slider (class)">MSPhysics::Slider</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Piston.html" title="MSPhysics::Piston (class)">MSPhysics::Piston</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/UpVector.html" title="MSPhysics::UpVector (class)">MSPhysics::UpVector</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Spring.html" title="MSPhysics::Spring (class)">MSPhysics::Spring</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Corkscrew.html" title="MSPhysics::Corkscrew (class)">MSPhysics::Corkscrew</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/BallAndSocket.html" title="MSPhysics::BallAndSocket (class)">MSPhysics::BallAndSocket</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Universal.html" title="MSPhysics::Universal (class)">MSPhysics::Universal</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Fixed.html" title="MSPhysics::Fixed (class)">MSPhysics::Fixed</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/CurvySlider.html" title="MSPhysics::CurvySlider (class)">MSPhysics::CurvySlider</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/CurvyPiston.html" title="MSPhysics::CurvyPiston (class)">MSPhysics::CurvyPiston</a></span></p>
</li><li>
<p><span class='object_link'><a href="MSPhysics/Plane.html" title="MSPhysics::Plane (class)">MSPhysics::Plane</a></span></p>
</li></ul>

<p>To demonstrate, how to use joint API extensively, lets assume our model has
two groups, named &#39;A&#39; and &#39;B&#39;. We want these groups to
connect to each other with a hinge joint, whenever they contact. We also
want them to disconnect whenever key X is pressed. This must be a
repetitive process.</p>

<p>There are various ways of coding it. One way is to create a Hinge object at
the beginning of simulation and connect/disconnect it when desired. Another
way is to create and connect a hinge joint whenever bodies A and B touch
and destroy the hinge joint when key X is pressed. The script below
utilizes the first approach, that is, the same Hinge object is used
whenever connecting and disconnecting:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onStart'>onStart</span> <span class='lbrace'>{</span>
  <span class='comment'># Find bodies A and B
</span>  <span class='ivar'>@bodyA</span> <span class='op'>=</span> <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_find_body_by_name'>find_body_by_name</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>A</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
  <span class='ivar'>@bodyB</span> <span class='op'>=</span> <span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_find_body_by_name'>find_body_by_name</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>B</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
  <span class='comment'># To create a hinge joint, we must pass the arguments denoted below:
</span>  <span class='comment'># Hinge.#initialize(world, parent, pin_tra, group = nil)
</span>  <span class='comment'># We will use body A as hinge parent and body B as hinge child.
</span>  <span class='comment'># We will use body A&#39;s transformation as pin_tra, which indicates joint
</span>  <span class='comment'># origin and axes.
</span>  <span class='comment'># The pin_tra will stick to the parent body as if it were part of it;
</span>  <span class='comment'># so, moving the parent body, will automatically rearrange the pin_tra.
</span>  <span class='comment'># This is viable because, if the parent body moved, when connecting the hinge
</span>  <span class='comment'># joint, it won&#39;t be necessary to respecify the pin_tra.
</span>  <span class='ivar'>@joint</span> <span class='op'>=</span> <span class='const'>Hinge</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_world'>world</span><span class='comma'>,</span> <span class='ivar'>@bodyA</span><span class='comma'>,</span> <span class='ivar'>@bodyA</span><span class='period'>.</span><span class='id identifier rubyid_get_matrix'>get_matrix</span><span class='rparen'>)</span>
<span class='rbrace'>}</span>

<span class='id identifier rubyid_onTouch'>onTouch</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_toucher'>toucher</span><span class='comma'>,</span> <span class='id identifier rubyid_point'>point</span><span class='comma'>,</span> <span class='id identifier rubyid_normal'>normal</span><span class='comma'>,</span> <span class='id identifier rubyid_force'>force</span><span class='comma'>,</span> <span class='id identifier rubyid_speed'>speed</span><span class='op'>|</span>
  <span class='comment'># Limit connection to body B only.
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_toucher'>toucher</span> <span class='op'>==</span> <span class='ivar'>@bodyB</span> <span class='comment'># We can also do this instead: if toucher.group.name == &#39;B&#39;
</span>    <span class='comment'># Connect body B to body A if not already connected.
</span>    <span class='ivar'>@joint</span><span class='period'>.</span><span class='id identifier rubyid_connect'>connect</span><span class='lparen'>(</span><span class='ivar'>@bodyB</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='op'>!</span><span class='ivar'>@joint</span><span class='period'>.</span><span class='id identifier rubyid_connected?'>connected?</span>
  <span class='kw'>end</span>
<span class='rbrace'>}</span>

<span class='id identifier rubyid_onTick'>onTick</span> <span class='lbrace'>{</span>
  <span class='comment'># Disconnect the joint whenever key x is pressed
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_key'>key</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>x</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='op'>==</span> <span class='int'>1</span> <span class='op'>&amp;&amp;</span> <span class='ivar'>@joint</span><span class='period'>.</span><span class='id identifier rubyid_connected?'>connected?</span>
    <span class='ivar'>@joint</span><span class='period'>.</span><span class='id identifier rubyid_disconnect'>disconnect</span>
  <span class='kw'>end</span>
<span class='rbrace'>}</span>
</code></pre>

<h2 id="label-Update+vs+Tick">Update vs Tick</h2>

<p>MSPhysics BodyContext has two events: <code>onUpdate</code> and
<code>onTick</code>. As well, as their cousins, <code>onPreUpdate</code>,
<code>onPostUpdate</code>, <code>onPreFrame</code>, and
<code>onPostFrame</code>. Meanwhile the tick/frame an the update events
have similar use, their purpose us not the same.</p>

<p>Simulation UI has an option, called <em>Update Rate</em>. <em>Update
Rate</em> indicates the number of times the physics world is to be updated
per frame. If the <em>Update Rate</em> were three, for example, the physics
world would be updating three times every frame, thus roughly increasing
the speed by a factor of three.</p>

<p>The update events are triggered [update_rate] times per frame. The
tick/frame events are triggered only one time per frame, regardless of the
update rate.</p>

<p>These events have different purposes.</p>

<p>The tick/frame events must be used for moving, drawing, controlling, and
manipulating SketchUp geometry. Since the viewport is redrawn only once per
frame, it would be unnecessary and performance consuming to move geometry
more than once per frame, from the update events. So geometry manipulation
functions must be called from <code>onPreFrame</code>, <code>onTick</code>,
or <code>onPostFrame</code> events.</p>

<p>Physics calculations and force/torque/velocity/omega controlling must be
performed through the <code>onPreUpdate</code>, <code>onUpdate</code>, or
<code>onPostUpdate</code> events.</p>

<p>Let&#39;s assume, the world update rate were three, and you called the
<code>add_force(force_vector)</code> function from the <code>onTick</code>
event. Because the <code>onTick</code> event is triggered only once per
frame, the force would be applied for only one of the three times the
physics world is updated:</p>

<pre class="code ruby"><code class="ruby">PhysicsWorldUpdate
ApplyForce
PhysicsWorldUpdate
PhysicsWorldUpdate
PhysicsWorldUpdate
ApplyForce
PhysicsWorldUpdate
PhysicsWorldUpdate
PhysicsWorldUpdate
ApplyForce
...</code></pre>

<p>This will result in a frequent jumping/bumping effect of the body the force
is applied to. If you were to call the <code>add_force(force_vector)</code>
function from the <code>onUpdate</code> event, the result would be a lot
smoother, because that way you&#39;re applying force every time the world
is updated:</p>

<pre class="code ruby"><code class="ruby">PhysicsWorldUpdate
ApplyForce
PhysicsWorldUpdate
ApplyForce
PhysicsWorldUpdate
ApplyForce
PhysicsWorldUpdate
ApplyForce
...</code></pre>

<p>To summarize it up, use the update events for applying forces, torques,
velocities, and omegas. Use the tick/frame events for controlling SketchUp
entities.</p>

<h2 id="label-Kinematic+Bodies">Kinematic Bodies</h2>

<p>Unlike dynamic bodies, kinematic bodies are static bodies with mass, that
are suitable for emulating movable platforms. Let&#39;s assume, your model
has a group that you want to use as a movable platform, that would
transition 10 meters, along the x-axis, back and forth, every 25 seconds.</p>

<p>One way of doing it is by assigning the platform a dynamic type and
connecting it to a piston joint, with controller set to <code>10 *
oscillator2(1/25.0)</code>.</p>

<p>Another way of doing it is by assigning the platform a kinematic type and
adding it the following script:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_onStart'>onStart</span> <span class='lbrace'>{</span>
  <span class='ivar'>@frequency</span> <span class='op'>=</span> <span class='int'>1</span><span class='op'>/</span><span class='float'>25.0</span>
  <span class='ivar'>@amplitude</span> <span class='op'>=</span> <span class='int'>10</span>
<span class='rbrace'>}</span>

<span class='id identifier rubyid_onPreUpdate'>onPreUpdate</span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_set_velocity'>set_velocity</span><span class='lparen'>(</span><span class='ivar'>@amplitude</span> <span class='op'>*</span> <span class='id identifier rubyid_oscillator2_slope'>oscillator2_slope</span><span class='lparen'>(</span><span class='ivar'>@frequency</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='int'>0</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_set_omega'>set_omega</span><span class='lparen'>(</span><span class='int'>0</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='int'>0</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_this'>this</span><span class='period'>.</span><span class='id identifier rubyid_integrate_velocity'>integrate_velocity</span><span class='lparen'>(</span><span class='id identifier rubyid_simulation'>simulation</span><span class='period'>.</span><span class='id identifier rubyid_update_timestep'>update_timestep</span><span class='rparen'>)</span>
<span class='rbrace'>}</span>
</code></pre>

<p>You may also assign a mass to a kinematic body to have its motion be
altered by the contacting bodies. See this link for more info: <a
href="http://newtondynamics.com/forum/viewtopic.php?f=9&t=9058">newtondynamics.com/forum/viewtopic.php?f=9&t=9058</a></p>
</div></div>

      <div id="footer">
  Generated on Tue Jul 11 13:23:33 2017 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.9 (ruby-2.3.3).
</div>

    </div>
  </body>
</html>